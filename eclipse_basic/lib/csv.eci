:- module(csv).
:- export struct(csv_options(strip, convert, type)).
:- export csv_read / 3.
:- export csv_options / 2.
:- export csv_read_row / 3.
:- export headers_map / 2.
:- export get_column / 4.
:- export csv_read_row / 2.
:- comment(summary, "Utilities to manipulate comma-separated (csv) format").
:- comment(author, "Joachim Schimpf").
:- comment(date, "$Date: 2015/01/14 01:31:08 $").
:- comment(copyright, "2010 by author").
:- comment(categories, ["Interfacing"]).
:- comment(csv_options / 2, [summary : "Precompile an option list for csv_read_row/3.", args : ["Options" : "Variable to be bound to csv_options/2 structure", "OptionList" : "List of options"], amode : (csv_options(-, +) is det), see_also : [csv_read_row / 3, struct(csv_options)]]).
:- comment(csv_read / 3, [summary : "Read a file containing comma separated values (csv format)", args : ["File" : "File name (string or atom)", "Rows" : "List of lists or structures (output)", "Options" : "List of options"], amode : (csv_read(+, -, +) is det), desc : html("<p>\n        Reads a file containing comma separated values, and returns the\n        file content as a list.  The file may have an optional .csv suffix.\n    </p><p>\n        The result list contains one element for each record/row in the\n        file.  By default, each list element is itself a list, containing\n        the row's field values.  Alternatively, the type-option can be used\n        to return structures instead of lists.\n    </p><p>\n        The data elements are strings, unless they can be interpreted as\n        numbers (by ECLiPSe's number_string/2 predicate) and the 'convert'\n        option is true (the default).\n    </p><p>\n        Options are:\n        <dl>\n        <dt>convert:Bool (default true)</dt>\n            <dd>If a field can be converted to an integer or float using\n            number_string/2, return this number.  Otherwise return a string.</dd>\n        <dt>strip:Bool (default false)</dt>\n            <dd>Strip leading and trailing space from the field value.\n            By default this is part of the data.</dd>\n        <dt>type:Type (default 'list')</dt>\n            <dd>Data type of returned rows: 'list' for a list of fields,\n            name/arity for terms with this functor (arity can be left\n            uninstantiated).</dd>\n        </dl>\n        \n    </p>\n    "), see_also : [number_string / 2, csv_read_row / 3], eg : "\n    % Given file data.csv containing the line:\n    % a, b, 123, c d,\" e f \"\n\n    ?- csv_read(\"data.csv\", Rows, []).\n    Rows = [[\"a\", \" b\", 123, \" c d\", \" e f \"]]\n\n    ?- csv_read(\"data.csv\", Rows, [strip:true, convert:false]).\n    Rows = [[\"a\", \"b\", \"123\", \"c d\", \" e f \"]]\n\n    ?- csv_read(\"data.csv\", Rows, [strip:true, type:row/N]).\n    Rows = [row(\"a\", \"b\", 123, \"c d\", \" e f \")]\n    N = 5\n"]).
:- comment(csv_read_row / 2, [summary : "Read one row of comma separated values (approximate)", args : ["Stream" : "Stream name or handle", "RowList" : "List of numbers and strings, or 'end_of_file' (output)"], amode : (csv_read_row(+, -) is det), desc : html("<p>\n        DEPRECATED - use csv_read_row/3.\n    </p><p>\n        Reads one row of comma separated values from Stream, and returns\n        the result as a list.  On end of file, returns the atom 'end_of_file'.\n    </p><p>\n        The result list contains one element for each field in the record.\n        The data elements are either numbers (if they can be interpreted\n        as numbers by ECLiPSe's number_string/2 predicate), or otherwise\n        strings.\n    </p><p>\n        Shortcomings: as opposed to csv_read_row/3, this predicate here uses the\n        ECLiPSe parser to read rows, and does not implement the csv format\n        fully.  E.g. empty fields are not handled and yield a syntax error.\n        However, when applicable, it will be faster than csv_read_row/3.\n    </p>\n    "), see_also : [number_string / 2, csv_read / 3, csv_read_row / 3]]).
:- comment(csv_read_row / 3, [summary : "Read a line containing comma separated values (csv format)", args : ["Stream" : "Input stream", "Row" : "List or structure (output)", "Options" : "List of options, or cvs_options-structure"], amode : (csv_read_row(+, -, +) is det), desc : html("<p>\n        Reads a single row from Stream containing comma separated values.\n    </p><p>\n        By default, the result is a list containing the row's field values.\n        Alternatively, the type-option can be used to return a structure\n        instead of list.\n    </p><p>\n        For other details see csv_read/3.\n    </p><p>\n        If csv_read_row/3 is called numerous times with complex options,\n        the option list should be precompiled using csv_options/2, and\n        the resulting structure passed as Options argument.\n    </p>\n    "), see_also : [csv_read / 3, csv_options / 2], eg : "\n    % Given file data.csv containing the line:\n    % a, b, 123, c d,\" e f \"\n    % 99, aa, bb, 123, C d\n\n    ?- open(\"data.csv\", read, S),\n       csv_read_row(S, Row1, []),\n       csv_read_row(S, Row2, []).\n    Row1 = [\"a\", \" b\", 123, \" c d\", \" e f \"]\n    Row2 = [99, \" aa\", \" bb\", 123, \" C d\"]\n\n    ?- open(\"data.csv\", read, S),\n       csv_options(Options, [strip:true, type:row/_]),\n       csv_read_row(S, Row1, Options),\n       csv_read_row(S, Row2, Options).\n    Row1 = row(\"a\", \"b\", 123, \"c d\", \"e f\")\n    Row2 = row(99, \"aa\", \"bb\", 123, \"C d\")\n"]).
