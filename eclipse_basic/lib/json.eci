:- module(json).
:- export json_read / 3.
:- export json_write / 3.
:- comment(categories, ["Interfacing"]).
:- comment(summary, "Read and write JSON format").
:- comment(author, "Joachim Schimpf").
:- comment(copyright, "Joachim Schimpf, Coninfer Ltd").
:- comment(date, "$2019$").
:- comment(json_read / 3, [summary : "Read a JSON element from a stream", args : ["Stream" : "Input stream", "JsonTerm" : "Term describing JSON object read", "Options" : "List of options"], amode : json_read(+, -, +), desc : html("\n    Read a JSON element.  In the resulting data structure, JSON elements are\n    represented as follows:\n    <DL>\n    <DT>object</DT>\n        <DD>Structure with functor {}/1 whose single argument is a list of\n        Name:Value terms, where Name is a string and Value a JSON element,\n        e.g. <CODE>{[\"a\":123,\"b\":[4,5]]}</CODE>, or the empty object <CODE>{}</CODE>.</DD>\n    <DT>array</DT>\n        <DD>A list whose elements are JSON elements, e.g. <CODE>[1,{\"a\":true}]</CODE></DD>\n    <DT>string</DT>\n        <DD>A string</DD>\n    <DT>number</DT>\n        <DD>An integer or float</DD>\n    <DT>true</DT>\n        <DD>the atom <CODE>true</CODE></DD>\n    <DT>false</DT>\n        <DD>the atom <CODE>false</CODE></DD>\n    <DT>null</DT>\n        <DD>the atom <CODE>null</CODE></DD>\n    </DL>\n    Options is a list that can contain\n    <DL>\n    <DT>names_as_atoms</DT>\n        <DD>return object key names as atoms instead of strings</DD>\n    </DL>\n    "), see_also : [json_write / 3], eg : "\n    ?- json_read(input, JsonTerm, []).\n     {\n       \"foo\":123,\n       \"bar\":[\"hello\",3,4.5],\n       \"baz\":true,\n       \"zut\":null\n     }\n     \n    JsonTerm = {[\"foo\":123, \"bar\":[\"hello\",3,4.5], \"baz\":true, \"zut\":null]}\n    Yes (0.00s cpu)\n\n\n    ?- json_read(input, JsonTerm, [names_as_atoms]).\n     {\n       \"foo\":123,\n       \"bar\":\"hello\",\n       \"baz\":true\n     }\n     \n    JsonTerm = {[foo:123, bar:\"hello\", baz:true]}\n    Yes (0.00s cpu)\n\n\n    ?- json_read(input, JsonTerm, []).\n     foobar\n\n     syntax error: invalid JSON syntax in json_read / 3\n    Abort\n"]).
:- comment(json_write / 3, [summary : "Write a JSON element to a stream", args : ["Stream" : "Output stream", "JsonTerm" : "Term describing JSON object to write", "Options" : "List of options"], amode : json_write(+, ++, +), desc : html("\n    Write a JSON element.  JSON elements are described by an ECLiPSe term\n    whose structure mimics the JSON element, as follows:\n    <DL>\n    <DT>object</DT>\n        <DD>Structure with functor {}/1 whose single argument is either\n        a comma-sequence of Name:Value terms, a list of Name:Value terms,\n        or a single Name:Value term.  Name is a string or atom, and Value\n        is another JSON element.  E.g. <CODE>{[\"a\":123,\"b\":[4,5]]}</CODE>\n        or <CODE>{\"a\":123,\"b\":[4,5]}</CODE>.\n        The empty object <CODE>{}</CODE> is also allowed.\n    <DT>array</DT>\n        <DD>A list or array whose elements are JSON elements, e.g.\n        <CODE>[1,{\"a\":true}]</CODE> or <CODE>[](1,{\"a\":true})</CODE></DD>\n    <DT>string</DT>\n        <DD>A string or atom</DD>\n    <DT>number</DT>\n        <DD>An integer or float</DD>\n    <DT>true</DT>\n        <DD>the atom <CODE>true</CODE></DD>\n    <DT>false</DT>\n        <DD>the atom <CODE>false</CODE></DD>\n    <DT>null</DT>\n        <DD>the atom <CODE>null</CODE></DD>\n    </DL>\n    Options is a list that can contain\n    <DL>\n    <DT>indent(N) - default 1</DT>\n        <DD>Indent each structure level by N spaces.\n        indent(0) suppresses all extra spaces and newlines.</DD>\n    <DT>float_format(String) - default \"%q\"</DT>\n        <DD>use the given printf-format to print floating point numbers,\n        e.g. \"%.3f\"</DD>\n    </DL>\n    "), see_also : [json_read / 3], eg : "\n    ?- json_write(output, [1, 2.3, foo, \"bar\"], []).\n    [\n     1,\n     2.3,\n     \"foo\",\n     \"bar\"\n    ]\n\n    ?- json_write(output, {foo:123, \"bar\":4.5, baz:true}, []).\n    {\n     \"foo\":123,\n     \"bar\":4.5,\n     \"baz\":true\n    }\n\n    ?- json_write(output, {[foo:123, \"bar\":4.5, baz:true]}, []).\n    {\n     \"foo\":123,\n     \"bar\":4.5,\n     \"baz\":true\n    }\n\n    ?- json_write(output, hello(world), []),\n    type error: expected json_term, found hello(world) in json_write / 3\n    Abort\n"]).
